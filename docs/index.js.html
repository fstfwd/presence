<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const ClientRegister = require('./lib/client-register');
const ClientMessager = require('./lib/client-messager');
const HTTP           = require('http');
const Initializers   = require('./initializers');
const Logger         = require('./lib/logger');
const Teamster       = require('teamster');
const UUID           = require('node-uuid');
const WSServer       = require('ws').Server;
const configureRedis = require('./initializers/configure-redis');
const app            = require('koa')();

/**
 * A collection of private functions, run automatically when the app starts, for
 * creating our Koa app and HTTP and WS servers.
 *
 * @module Main
 */

Initializers.start()
  .then(() => {
    createTeamster();
    process.once('SIGINT', onInt);
    process.once('SIGTERM', onTerm);
  }).catch(err => { throw err; });

/**
 * Start 1 or more web processes running our app.
 *
 * @private
 */
function createTeamster() {
  Teamster.run(startServers, {
    fork      : process.env.NODE_ENV === 'production',
    numWorkers: parseInt(process.env.NUM_WORKERS, 10) || 1,
  });
}

/**
 * Start HTTP and WS servers for our app.
 *
 * @private
 */
function startServers() {
  const port = parseInt(process.env.PORT, 10) || 5000;

  HTTP.createServer(app.callback()).listen(port, () => {
    Logger.log({ event: `HTTP server listening on port ${port}` });
    startWSServer(this);
  });
}

/**
 * Start a WS server for handling WebSocket connections.
 *
 * @private
 * @param {HTTP.Server} httpServer The httpServer to attach the WS server to
 */
function startWSServer(httpServer) {
  const wsServer = new WSServer({ server: httpServer });
  wsServer.on('connection', onConnection);
}

/**
 * Handle a newly connected WebSocket connection
 *
 * @private
 * @param {WS.WebSocket} socket The new WebSocket connection
 */
function onConnection(socket) {
  const clientID = socket.upgradeReq.headers['x-request-id'] || UUID.v4();

  ClientRegister.registerClient(clientID, socket).then(client => {
    Logger.log({ id: client.id, event: 'New WebSocket client connected' });
    client.socket.on('close', () => onClose(client));
    client.socket.on('message', message => onMessage(client, message));
  }).catch(err => {
    ClientMessager.error({ socket: socket }, 'Error when joining new client');
    Logger.log({ id: clientID, event: 'Could not create new client' });
    Logger.error(err);
    socket.close();
  });
}

/**
 * Handle a message sent by a client.
 *
 * @private
 * @param {Client} client The client that sent the message
 * @param {string} message The message sent by the client
 */
function onMessage(client, message) {
  try {
    message = JSON.parse(message);
  } catch(err) {
    Logger.error(err);
    ClientMessager.error(client, 'Unparsable message sent');
    return;
  }

  if (message.action !== 'ping') {
    const err = `Unrecognized action sent: ${message.action}`;
    Logger.log({ id: client.id, event: err });
    ClientMessager.error(client, err);
    return;
  }

  ClientRegister.renewClient(client).then(() => {
    Logger.log({ id: client.id, event: 'Presence renewed' });
  });
}

/**
 * Handle a client's socket closing.
 *
 * @private
 * @param {Client} client The client whose socket has closed.
 */
function onClose(client) {
  Logger.log({ id: client.id, event: 'Client closed socket connection' });
  ClientRegister.deregisterClient(client);
}

/**
 * Handle a 'SIGINT', where all clients must be removed.
 *
 * @private
 */
function onInt() {
  onTerm().then(() => {
    process.kill(process.pid, 'SIGINT');
  });
}

/**
 * Handle a 'SIGTERM', where all clients must be removed.
 *
 * @private
 * @return {Promise} A promise resolved after termination and a new SIGTERM has
 *   been sent
 */
function onTerm() {
  return ClientRegister.terminate().then(() => {
    process.kill(process.pid, 'SIGTERM');
  });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Client.html">Client</a></li><li><a href="module-ClientMessager.html">ClientMessager</a></li><li><a href="module-ClientRegister.html">ClientRegister</a></li><li><a href="module-Initializers.html">Initializers</a></li><li><a href="module-Logger.html">Logger</a></li><li><a href="module-Main.html">Main</a></li><li><a href="module-Observer.html">Observer</a></li><li><a href="module-Redis.html">Redis</a></li></ul><h3>Global</h3><ul><li><a href="global.html#configureRedis">configureRedis</a></li><li><a href="global.html#startObserver">startObserver</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
